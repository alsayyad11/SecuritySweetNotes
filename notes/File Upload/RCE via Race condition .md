<p align="center">
  <img src="https://github.com/user-attachments/assets/362c23d3-9315-4f76-9985-8afa46396f60" alt="image" width="700"/>
</p>

---

## 1. Race Conditions During File Uploads

### Problem 

* Modern frameworks upload files securely by first saving them to a temporary sandboxed folder with randomized filenames to avoid overwriting or unintended execution.
* After this, thorough validation occurs (e.g., antivirus scanning, content verification).
* Only once the file is deemed safe is it moved to its final destination.
* However, some developers implement custom upload handling without these safeguards, creating a **race condition** where the file exists on the server for a short time before validation.
* During this window, attackers can access and execute the file.

### How to Exploit it

* Upload a malicious script (e.g., `shell.php`) with code for server command execution.
* Quickly request the file URL (e.g., `http://site.com/uploads/shell.php`) during the brief window before the file is deleted or moved.
* If accessible, the malicious code runs on the server.

### PoC

Insecure PHP upload code:

```php
<?php
if ($_FILES['file']['error'] === UPLOAD_ERR_OK) {
    $uploadPath = 'uploads/' . basename($_FILES['file']['name']);
    move_uploaded_file($_FILES['file']['tmp_name'], $uploadPath);

    // Simulate delay for antivirus scan
    sleep(3);

    // Fake scan result (file unsafe)
    $isSafe = false;

    if (!$isSafe) {
        unlink($uploadPath);
        echo "File removed!";
    } else {
        echo "File uploaded successfully.";
    }
}
?>
```

**Exploitation :**
The attacker uploads `shell.php` with:

```php
<?php phpinfo(); ?>
```

Then quickly visits `uploads/shell.php` within the 3-second delay to execute the code.

### How to Fix it 

* Upload files first to a non-executable temporary folder (sandbox).
* Use randomized file names to prevent guessing.
* Do not allow execution from the temporary upload folder.
* Only move the file to the final folder after full validation.
* Prevent uploading .htaccess files entirely in upload directories, and use server configuration (e.g., `.htaccess` in Apache) to disable script execution in those directories.

### Secure Upload Example:

```php
<?php
if ($_FILES['file']['error'] === UPLOAD_ERR_OK) {
    $randomName = bin2hex(random_bytes(16)) . '.' . pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION);
    $tmpPath = 'tmp_uploads/' . $randomName;

    move_uploaded_file($_FILES['file']['tmp_name'], $tmpPath);

    // Antivirus scan simulation
    sleep(3);

    $isSafe = true; // Assume scan passed

    if ($isSafe) {
        rename($tmpPath, 'uploads/' . $randomName);
        echo "File uploaded successfully.";
    } else {
        unlink($tmpPath);
        echo "File removed!";
    }
}
?>
```

---

## 2. Race Conditions in URL-Based File Uploads

### Problem 

* Some websites allow users to upload files by providing a URL.
* The server downloads the file to a temporary folder with a name generated by weak functions (e.g., PHP’s `uniqid()`).
* During the download and validation, there is a time window where the file exists on the server.
* If the folder name is predictable, attackers can brute-force or guess it to access the file before validation finishes.
* Large files extend the download time, increasing the attack window.

### How to Exploit it

* Upload a large file with a malicious payload at the start and padding afterward.
* Guess the temporary folder name if generated predictably.
* Send rapid requests to access the file during the download process.

### PoC

* Payload starts the file, followed by a large amount of padding data to increase processing time.
* Guessing folder names generated by `uniqid()` is easier since it’s predictable.

### How to Fix it

* Use strong random generators (e.g., UUID, `random_bytes()`) for temporary folder/file names.
* Restrict direct access to temporary upload directories.
* Set strict folder permissions.
* Limit allowed file sizes to reduce processing time.
* Implement strict validation before allowing access to uploaded files.

---

## 3.  File Uploads Without Remote Code Execution (Non-RCE Attacks)

### Problem 

* Even if the server prevents executing uploaded files, attackers can upload files that trigger client-side attacks.
* For example, uploading HTML or SVG files containing malicious JavaScript payloads can lead to stored XSS attacks.
* If the uploaded file is served from the same origin and accessed by users, the embedded script executes in their browsers.
* Another vector is exploiting vulnerabilities in file parsers for XML-based files (e.g., `.doc`, `.xls`), leading to XML External Entity (XXE) injection.

### How to Exploit This

* Upload SVG with embedded script:

```xml
<svg onload="alert('XSS')"></svg>
```

* Upload XML containing XXE payload:

```xml
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<foo>&xxe;</foo>
```

### How to Fix it

* Block or sanitize HTML and SVG uploads using libraries like `DOMPurify`.
* Implement Content Security Policy (CSP) headers to prevent script execution from untrusted sources:

```
Content-Security-Policy: default-src 'self';
```

* Disable external entities in XML parsers to prevent XXE.
* Use secure, updated parsing libraries.
* Strictly verify MIME types and file extensions.
* Sanitize all inputs containing executable code.

---

## some of Best Practices for Secure File Uploads

* Always use unpredictable, randomized file names.
* Never allow uploads to executable directories.
* Use whitelist for allowed file types.
* Validate MIME types and file signatures (magic bytes).
* Limit maximum file size.
* Isolate upload processes in sandboxed environments.
* Use antivirus scanning when possible.
* Set security headers like `X-Content-Type-Options: nosniff` and CSP.
* Enforce authentication and authorization for uploads.

---

